class_name Laser extends RayCast3D
const ColorRYB = ColorRYB_Operations.ColorRYB

@onready var area_of_effect = $AreaOfEffect
@onready var area_of_effect_shape = ($AreaOfEffect/CollisionShape3D).shape as CylinderShape3D
@onready var beam_mesh = $BeamMesh
@onready var beam_material = beam_mesh.get_surface_override_material(0)
@onready var end_particles = $EndParticles
@onready var end_particles_material = end_particles.material_override
@onready var beam_particles = $BeamParticles
@onready var beam_particles_material = beam_particles.material_override

var tween: Tween
#var beam_radius: float = 0.03

var color: ColorRYB = ColorRYB.Red:
	set(new_color):
		color = new_color
		var temp = ColorRYB_Operations.ToColor(new_color)
		beam_material.albedo_color = temp
		beam_material.emission = temp
		end_particles_material.albedo_color = temp
		end_particles_material.emission = temp
		beam_particles_material.albedo_color = temp
		beam_particles_material.emission = temp

@export var distance: float = 1
@export var intensity: float = 10

var last_colliding_object: BaseTower = null
var encountered_prisms = []

func set_params(color1, distance1, intensity1):
	color = color1
	distance = distance1
	intensity = intensity1
	set_update_flag()

func _exit_tree() -> void:
	if last_colliding_object != null:
		if (last_colliding_object is BaseTower):
			(last_colliding_object as BaseTower).end_laser_collision(self)

var update_flag = false
func set_update_flag():
	update_flag = true

func update():
	target_position = Vector3(0, distance, 0)
	force_raycast_update()
	var collider = get_collider()
	
	var beam_length = distance
	var beam_end_position = Vector3(0, distance, 0)
	
	if (collider == null):
		if (last_colliding_object != null):
			last_colliding_object.end_laser_collision(self)
			last_colliding_object = null
	else:
		var new_colliding_object = collider.get_parent() as BaseTower
		if (last_colliding_object == new_colliding_object):
			last_colliding_object.continue_laser_collision(self, collider)
		else:
			if(last_colliding_object != null):
				last_colliding_object.end_laser_collision(self)
			new_colliding_object.begin_laser_collision(self, collider)
			last_colliding_object = new_colliding_object
			
		beam_length = to_local(get_collision_point()).length()
		beam_end_position = to_local(get_collision_point())
	
	beam_mesh.mesh.height = beam_length
	beam_mesh.position.y = beam_length / 2
	area_of_effect_shape.height = beam_length
	area_of_effect.position.y = beam_length / 2
	end_particles.position = beam_end_position

func _process(_delta):
	if update_flag:
		update()
		update_flag = false

func _physics_process(_delta):
	var enemies_in_aoe = area_of_effect.get_overlapping_areas()

	for enemy in enemies_in_aoe:
		enemy = enemy.get_parent()
		if (enemy is BaseEntity):
			pass
			(enemy as BaseEntity).TakeDamage(intensity*_delta, color)

#======================================================================
# Outdated, because it doesnt pass activation/deactivation to lasers generated by this one through towers.
# I'll leave it here because animation is cool.

#func activate(time: float):
	#tween = get_tree().create_tween()
	#visible = true
	#beam_particles.emitting = true
	#end_particles.emitting = true
	#tween.set_parallel(true)
	#tween.tween_property(beam_mesh.mesh, "top_radius", beam_radius, time)
	#tween.tween_property(beam_mesh.mesh, "bottom_radius", beam_radius, time)
	#tween.tween_property(beam_particles.process_material, "scale_min", 1, time)
	#tween.tween_property(end_particles.process_material, "scale_min", 1, time)
	#await tween.finished
#
#func deactivate(time: float):
	#tween = get_tree().create_tween()
	#tween.set_parallel(true)
	#tween.tween_property(beam_mesh.mesh, "top_radius", 0.0, time)
	#tween.tween_property(beam_mesh.mesh, "bottom_radius", 0.0, time)
	#tween.tween_property(beam_particles.process_material, "scale_min", 0.0, time)
	#tween.tween_property(end_particles.process_material, "scale_min", 0.0, time)
	#await tween.finished
	#visible = false
	#beam_particles.emitting = false
	#end_particles.emitting = false
