class_name Laser extends RayCast3D

@onready var area_of_effect = $AreaOfEffect
@onready var area_of_effect_shape = ($AreaOfEffect/CollisionShape3D).shape as CylinderShape3D
@onready var beam_mesh = $BeamMesh
@onready var beam_material = beam_mesh.get_surface_override_material(0)
@onready var end_particles = $EndParticles
@onready var end_particles_material = end_particles.material_override
@onready var beam_particles = $BeamParticles
@onready var beam_particles_material = beam_particles.material_override

var tween: Tween
var beam_radius: float = 0.03

@export var color: Color = Color.RED:
	set(new_color):
		color = new_color
		beam_material.albedo_color = new_color
		beam_material.emission = new_color
		end_particles_material.albedo_color = new_color
		end_particles_material.emission = new_color
		beam_particles_material.albedo_color = new_color
		beam_particles_material.emission = new_color

@export var distance: float = 1
@export var intensity: float = 10

var last_colliding_object: BaseTower = null

func _ready():
	pass

func _exit_tree() -> void:
	if last_colliding_object != null:
		if (last_colliding_object is BaseTower):
			(last_colliding_object as BaseTower).end_laser_collision(self)

func _process(delta):
	target_position = Vector3(0, distance, 0)
	force_raycast_update()
	var collider = get_collider()
	
	var beam_length = distance
	var beam_end_position = Vector3(0, distance, 0)
	
	if (collider == null):
		if (last_colliding_object != null):
			last_colliding_object.end_laser_collision(self)
			last_colliding_object = null
	else:
		var new_colliding_object = collider.get_parent() as BaseTower
		if (last_colliding_object == new_colliding_object):
			last_colliding_object.continue_laser_collision(self)
		else:
			if(last_colliding_object != null):
				last_colliding_object.end_laser_collision(self)
			new_colliding_object.begin_laser_collision(self)
			last_colliding_object = new_colliding_object
			
		beam_length = to_local(get_collision_point()).length()
		beam_end_position = to_local(get_collision_point())
	
	beam_mesh.mesh.height = beam_length
	beam_mesh.position.y = beam_length / 2
	area_of_effect_shape.height = beam_length
	area_of_effect.position.y = beam_length / 2
	end_particles.position = beam_end_position
	
	var enemies_in_aoe = area_of_effect.get_overlapping_areas()

	for enemy in enemies_in_aoe:
		enemy = enemy.get_parent()
		if (enemy is BaseEntity):
			pass
			#(enemy as BaseEntity).TakeDamage(intensity, color)

#======================================================================
# Outdated, because it doesnt pass activation/deactivation to lasers generated by this one through towers.
# I'll leave it here because animation is cool.

func activate(time: float):
	tween = get_tree().create_tween()
	visible = true
	beam_particles.emitting = true
	end_particles.emitting = true
	tween.set_parallel(true)
	tween.tween_property(beam_mesh.mesh, "top_radius", beam_radius, time)
	tween.tween_property(beam_mesh.mesh, "bottom_radius", beam_radius, time)
	tween.tween_property(beam_particles.process_material, "scale_min", 1, time)
	tween.tween_property(end_particles.process_material, "scale_min", 1, time)
	await tween.finished

func deactivate(time: float):
	tween = get_tree().create_tween()
	tween.set_parallel(true)
	tween.tween_property(beam_mesh.mesh, "top_radius", 0.0, time)
	tween.tween_property(beam_mesh.mesh, "bottom_radius", 0.0, time)
	tween.tween_property(beam_particles.process_material, "scale_min", 0.0, time)
	tween.tween_property(end_particles.process_material, "scale_min", 0.0, time)
	await tween.finished
	visible = false
	beam_particles.emitting = false
	end_particles.emitting = false
